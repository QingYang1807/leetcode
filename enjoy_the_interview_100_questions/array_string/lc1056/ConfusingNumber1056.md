# 1056 易混淆数

<span style="background-color: #57bb8a; color: #fff; padding: 4px 8px; border-radius: 4px;">简单</span>



[地址](https://leetcode.cn/problems/confusing-number/?envType=study-plan-v2&envId=premium-algo-100)

## 题目

给定一个数字 `N`，当它满足以下条件的时候返回 `true`：

原数字旋转 180° 以后可以得到新的数字。

如 0, 1, 6, 8, 9 旋转 180° 以后，得到了新的数字 0, 1, 9, 8, 6 。

2, 3, 4, 5, 7 旋转 180° 后，得到的**不是**数字。

易混淆数 (confusing number) 在旋转180°以后，可以得到和原来**不同**的数，且新数字的每一位都是有效的。

 

**示例 1：**

![img](.\pic\1268_1.png)

```
输入：6
输出：true
解释： 
把 6 旋转 180° 以后得到 9，9 是有效数字且 9!=6 。
```

**示例 2：**

![img](.\pic\1268_2.png)

```
输入：89
输出：true
解释: 
把 89 旋转 180° 以后得到 68，86 是有效数字且 86!=89 。
```

**示例 3：**

![img](.\pic\1268_3.png)

```
输入：11
输出：false
解释：
把 11 旋转 180° 以后得到 11，11 是有效数字但是值保持不变，所以 11 不是易混淆数字。 
```

**示例 4：**

![img](.\pic\1268_4.png)

```
输入：25
输出：false
解释：
把 25 旋转 180° 以后得到的不是数字。
```

**提示：**

1. `0 <= N <= 10^9`
2. 可以忽略掉旋转后得到的前导零，例如，如果我们旋转后得到 `0008` 那么该数字就是 `8` 。

## 思路

题目要求判断一个数字在旋转180°后是否变成了一个不同的数字。我们可以将旋转后的数字与原数字进行比较，如果不同则返回true，否则返回false。

首先，我们需要确定每个数字旋转180°后的对应数字。根据题目给出的旋转规则，0旋转后变成0，1旋转后变成1，6旋转后变成9，8旋转后还是8，9旋转后变成6。我们可以建立一个映射关系的数组来表示这个规则。

然后，我们将原数字逆序读取，并根据映射关系数组得到旋转后的数字。如果旋转后的数字与原数字不相等，则返回true；如果所有位数都相等，则返回false。

## 代码

```java
public boolean confusingNumber(int n) {
    int[] rotateMap = { 0, 1, -1, -1, -1, -1, 9, -1, 8, 6 }; // 旋转规则映射关系数组
    
    int num = n;
    int rotateNum = 0;
    while (num > 0) {
        int digit = num % 10; // 取得原数字的最后一位
        if (rotateMap[digit] == -1) {
            return false; // 如果最后一位数字旋转后不是有效数字，则直接返回false
        }
        rotateNum = rotateNum * 10 + rotateMap[digit]; // 构建旋转后的数字
        num /= 10; // 去掉原数字的最后一位
    }
    
    return rotateNum != n; // 判断旋转后的数字与原数字是否不相等
}
```

## 复杂度分析

时间复杂度：假设N有k位数字，则时间复杂度为*O(k)*，其中k为数字N的位数。

空间复杂度：空间复杂度为*O(1)*，只使用了常数大小的额外空间。
